- [DONE] Move GLFWwindow outside of the Wsi struct. Introduce a Platform struct that handles:
	- [DONE] Window creation
	- [DONE] Keyboard Input
	- [DONE] Mouse Input

- Move the pipeline creation to a Shader/Pipeline struct outside the Renderer

- [WIP] Add a Simulation struct that holds the GameState. The GameState struct could include things like:
	- GameObjects related data
		- [DONE] Entities (static ones like walls, grounds. dynamic ones like players and enemies)
		- [DONE] Meshes 
		- [DONE] Transforms (vec3 position, vec3 scale, quat rotation)
		- ...
	- [WIP] Input data
		- [WIP] Keyboard input states
		- [DONE] Mouse cursor position

	- [WIP] In general the game state should be split into "section" that are going to be read/written
	  by separate "system", like Simulation, Renderer, Vulkan, Audio

- Figure out what the Renderer API should look like. Some methods would be
	- upload_mesh()
	- [DONE] upload_static_transforms()
	- [DONE] upload_dynamic_transforms()
	- upload_uniforms()
	- ect...
	- DebugDraw
		- We need to provide debug drawing functions to draw things like grids, lines, axis gizmos, camera frustums

- [WIP] Implement a Camera struct that can function as a:
	- [DONE] game camera (perspective), fixed in place that looks on the game board
	- [DONE] debug camera to freely move in the world
	- "cinematic" camera that can transition between source and target position and rotation, 
	  with dedicated "animation curves"

- Implement a Clock struct (based on the one in Game Engine Architecture)

- [WIP] Adapt the glTF asset importer to the new code

- Memory Management
	- Linear Allocator
	- [DONE] Stack Allocator
	- Move Game::State data into a Stack